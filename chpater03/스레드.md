---
### 스레드
---
지금까지 살펴본 프로세스는 프로그램을 실행하는 자원과 실행되는 제어의 흐름(디스패칭되는 개체)이라는 두 가지 특성으로 나누어 볼 수 있다. 현대의 운영체제는 프로세스에서 실행제어만 분리한 실행 단위를 스레드(또는 경량 프로세스(LWP,Light Weight Process))라 하고 자원 단위의 처리를 프로세스(또는 작업)로 나누어 처리한다. 그리고 프로세스에서 실행되는 제어의 흐름을 분리하면, 즉 스레드의 개념을 분리하면 실행 상태와 디스패칭의 우선순위문제를 생각해 볼 수 있다.

---
#### 스레드 개요
---
스레드는 프로세스처럼 프로세서를 사용하는 기본 단위이면서 프로그램을 실행하는 프로세스 내의 개체, 즉 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름이다. 스레드는 같은 그룹의 스레드와 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유하는데, 이러한 스레드의 그룹 환경을 작업이라 한다. 따라서 스레드를 경량 프로세스(LWP, Light Weight Process)라고 부르는데, 전형적인 프로세스, 즉 중량 프로세스(HWP,Heavy Weight Process)는 스레드를 하나 가진 작업이다. 작업에 스레드가 없으면 아무 일도 할 수 없으므로 작업에는 반드시 스레드가 있어야 한다. 

프로세스는 스레드를 하나 이상 가지며 각 스레드는 다음 내용을 포함한다.

- 스레드 실행 시의 상태(실행,준비 등)

- 실행 스택

- 지역 변수와 스레드의 특정 데이터를 저장하기 위한 스레드별 정적 저장소

- 프로세스의 다른 스레드가 공유하는 프로세스의 메모리와 자원에 대한 접근 같은 스레드 실행 환경 정보(문맥 정보)

스레드를 사용하면 자원을 공유하여 한 프로세스에서 동시 작업이 가능하다. 즉, 프로세스에 포함된 스레드들은 공통의 목적을 달성하기 위해 병렬로 수행된다. 또한 하나의 프로세스가 서로 다른 프로세서에서 프로그램의 다른 부분을 동시에 실행시킬 수 있으므로 시스템의 성능과 효율을 향상시킨다. 따라서 응용 프로그램 하나가 비슷한 작업들을 여러 개 수행할 수 있다.

---
##### 사용자에 대한 응답성 증가
---
응용 프로그램에서 일부분이 봉쇄되거나 긴 작업을 수행해도 프로그램 실행을 계속 허용하여 사용자에 대한 응답성이 증가한다. 예를 들면, 다중 스레드가 적용된 웹 브라우저는 스레드 하나가 파일을 적재하는 동안, 다른 스레드에서 사용자와 상호작용이 가능하다. 

---
##### 프로세스의 자원과 메모리 공유 기능
---
스레드는 그들이 속한 프로세스의 자원과 메모리를 공유한다. 그러므로 응용 프로그램 하나가 같은 주소 공간에서 여러 개의 스레드를 실행해 시스템 성능을 향상시키고 편리함을 제공한다.

---
##### 경제성
---
스레드는 한 프로세스의 자원을 공유한다. 그러므로 메모리와 자원을 할당해 프로세스를 생성하는 것보다 스레드를 생성하여 문맥 교환하는 것이 오버헤드를 줄인다.

---
#### 다중 프로세서 구조 활용 가능
---
다중 프로세서 구조에서 각 스레드는 다른 프로세서에서 병렬로 실행될 수 있다.

---
### 단일 스레드와 다중 스레드
---
운영체제는 단일 프로세스에서 단일 스레드 실행과 다중 스레드 실행을 지원한다. 

단일 스레드를 지원하는 운영체제는 프로세스 하나에 스레드 하나가 실행되는 전통적인 방식으로 스레드의 개념이 불확실하다. 대표 예가 MS-DOS다. 다중 스레드 운영체제는 프로세스 하나에 스레드를 실행하는 것을 지원하는 형태로 윈도우 NT/XP, 솔라리스 등이 이에 해당한다. 물론 프로그램 하나를 여러 실행 단위로 쪼개어 실행한다는 측면에서(각 스레드를 별도의 프로세서에서 실행) 다중 프로세싱(프로세서)과 같은 의미다. 하지만 동일한 동일 프로세스 내의 스레드는 메모리와 파일을 공유하기 때문에, 프로세스 하나에 다수의 실행 단위로 구분된 자원을 공유하므로 자원 생성과 관리의 중복성을 최소화하여 실행 능력을 향상시킬 수 있다. 이때 각 스레드는 커널 개입 없이 서로 통신이 가능하여 독립적으로 실행할 수 있어 서버에서 많은 요청을 효과적으로 처리할 수 있는 환경을 제공해준다. 

단일 스레드 프로세스 모델은 프로세스를 하나의 스레드, 즉 스레드가 가진 레지스터와 스택으로 표현한다. 반면 다중 스레드 프로세스 모델은 프로세스를 각각의 스레드와 고유의 레지스터, 스택으로 표현하며 프로세스 주소 영역을 모든 스레드가 공유한다. 따라서 프로세스의 모든 스레드는 해당 프로세스의 자원과 상태를 공유하고, 같은 주소 공간에 존재하며, 동일한 데이터에 접근한다. 이때 스레드 하나가 메모리에 있는 데이터 항목을 변경하면 다른 스레드도 이 항목에 접근하여 변경 결과를 확인할 수 있다. 또한 스레드 하나가 읽기 권한으로 파일을 열면 같은 프로세스의 다른 스레드도 이 파일을 읽을 수 있다. 이러한 스레드의 특성은 프로세스의 생성과 종료 과정에 매우 유용하다.

이러한 스레드의 특성으로 프로세스를 새로 생성하는 것보다 기존 프로세스에서 스레드를 생성하는 것이 빠르고, 같은 프로세스에 있는 스레드 간 교환이나 스레드 종료도 훨씬 빠르다.

따라서 스레드는 프로세스의 상대적인 무게를 줄여 효율을 극대화하는 것을 목표로, 프로그램 변경 없이 프로세서의 개수에 따라 스레드를 병렬로 처리할 수 있다.

스레드별로 레지스터 상태를 가지지만 서로 공유를 많이 하기 때문에 같은 그룹의 스레드에 프로세서를 할당하거나 스레드를 생성할 때 중량 프로세스들 사이의 문맥교환과 비교하면 훨씬 경제적이다. 

---
### 스레드 용법
---
스레드 개념을 사용자 수준에서 제공하기도 하는데, 시스템 호출이 아닌 사용자 라이브러리 수준에서 제공되므로 운영체제와 무관하여(커널이 직접 제어하지 않아) 매우 빨리 일어난다. 예를 들어, 단일 사용자 다중 처리 시스템에서 전면 작업과 후면 작업의 실행 과정을 살펴보면 하나의 스레드는 사용자의 데이터 입력을 읽어 들이고 메뉴를 표시하며, 다른 하나의 스레드는 사용자 명령을 실행하는 등 프로그램의 이저너 명령이 완료되기 전에 다음 명령을 신속하게 준비하여 응용 프로그램의 속도를 향상시킬 수 있다. 또한 프로그램에 비동기적 요소를 구현할 수 있다. 예를 들어, 워드 프로세서가 지정 시간에 메모리 내용을 디스크에 백업하도록 정기적인 백업 스레드를 생성할 수 있다.

또한 현재 실행되는 스레드를 대기 상태에 놓고 다른 스레드로 제어를 이동시키는 상태 변화는 하나의 서버가 많은 요청을 받아들여 처리하는 효과적인 방법이 될 수 있다. 예를 들면, 다중 스레드가 적용된 웹 브라우저는 한 스레드가 이미지나 텍스트를 적재하는 동안 다른 스레드가 네트워크 연결을 통해 사용자(클라이언트)와 상호 작용할 수 있다. 따라서 웹 서버는 여러 개의 클라이언트가 동시에 접근하여 웹 페이지나 이미지 파일에 대한 요청을 처리할 수 있다.

공유 메모리 형태의 다중 프로세서 시스템 환경에서는 프로그램을 공유 메모리에 저장하고 스레드를 각 프로세서에 할당, 병렬 처리하여 프로세서 성능을 매우 향상시킬 수 있다. 

많은 데이터베이스 시스템에서 스레드 기법을 적용하고 있다. 하지만 스레드는 단점도 있다. 사용자 수준 스레드는 커널 자체가 스레드 하나로 구성되어 있기 때문에 한 스레드에서 시스템 호출을 실행할 때 해당 스레드가 포함된 전체의 작업이 시스템 호출 결과가 돌아올 때까지 기다려야 한다. 

---
### 스레드의 상태 변화
---
스레드와 프로세스는 공통점이 상당히 많으며, 프로세스처럼 준비, 실행, 대기, 종료 상태로 구분한다. 스레드들은 프로세서를 함께 사용하고 항상 스레드 하나만 실행된다. 또한 한 프로세스에 있는 스레드는 순차적으로 실행되고 자신의 정보를 위한 프로그램 카운터와 스택을 가지고 있다.

일반적으로 새로운 프로세스가 생성되면 프로세스를 위한 스레드도 함께 생성된다. 스레드 생성에서는 운영체제가 부모 프로세스와 공유할 자원을 초기화할 필요가 없다. 프로세스 내의 스레드는 해당 프로세스에서 다른 스레드를 생성하고 새로 형성된 위한 스택과 레지스터를 제공한다. 따라서 프로세스의 생성과 종료 스레드 생성과 종료 과정의 오버헤드가 훨씬 적다. 

스레드의 각 대기 상태는 다음과 같다.

- 대기 : 스레드가 이벤트를 기다릴 때, 즉 입출력 작업 등이 완료될 때까지 스레드는 대기(보류) 상태가 되며 이때 자신의 정보(프로그램 카운터, 스택 포인터 등)를 실행 스택에 저장한다. 

- 준비 : 스레드가 프로세서에 의해 실행될 수 있는 상태다. 스레드를 대기시킨 이벤트(입출력이 완료되면)가 발생하면 해당 스레드는 준비 리스트에 삽입된다.

- 실행 : 스레드가 프로세서를 점유하여 실행 중인 활성화 상태다. 

- 종료 : 스레드가 작업을 종료하면 자원을 해제하고 레지스터 문맥과 스택 할당이 제거된다.

여기서 하나의 스레드가 대기 상태로 변할 때 전체 프로세스를 대기 상태로 변화시키지 않는다는 점이 스레드의 유연적인 장점이다. 

하나의 스레드가 대기 상태에 있으면 다른 스레드가 실행될 수 있다. 그러나 프로세스와 달리 서로 독립적이지 않다. 한 작업에 있는 모든 스레드는 작업의 모든 주소에 접근할 수 있으므로 한 스레드가 다른 스레드의 스택을 읽거나 덮어 쓸 수 있다. 

따라서 보호 문제가 발생할 수 있지만 보호 문제는 사실상 염려할 필요가 없다. 프로세스는 다수의 사용자에게서 발생하며 경쟁적인 자원 요구와 서로 다른 관계를 유지해야 하지만, 스레드는 한명의 사용자가 여러 스레드를 가진 작업 하나를 사용하여 오히려 도움을 줄 수 있기 때문이다. 

---
### 스레드 구현
---
여러 수준에서 스레드를 구현할 수 있다. 운영체제에 따라 다르지만 일반적으로 사용자 수준과 커널 수준 혹은 두 수준을 혼합한 방식 중 하나를 사용한다. 사용자 수준에서 지원되는 스레드는 스레드 사이에 커널이 개입하지 않아 커널 수준보다 속도가 빠르다.

#### 사용자 수준 스레드

사용자 수준 스레드는 커널 스레드를 지원하지 않는 운영체제에서 사용한다. 사용자 수준 스레드 여러 개가 커널 스레드(프로세스) 하나로 매핑되는 방식이다. 즉, 다중 스레드 프로세스에 대해 프로세서를 하나 할당하기 때문에 다대일 스레드 매핑이라고 한다. 물론 사용자 수준(공간)에서 스레드 관리가 효율적으로 이루어지므로 스레드와 관련된 모든 과정을 응용 프로그램이 수행한다. 이때 커널은 스레드의 존재를 모른다. 응용 프로그램은 사용자 수준 스레드 관리를 위한 루틴으로 구성된 스레드 라이브러리를 이용하며 다중 스레드로 프로그래밍할 수 있다.

스레드 라이브러리는 스레드 생성과 종료, 문맥 교환을 위한 코드, 동기화, 메모리 할당, 스레드 간의 메시지 전달, 스레드 실행 스케줄링 같은 정보를 포함한다. 스레드 라이브러리의 생성 유틸리티를 통해 생성되며, 제어는 프로시저 호출을 통해 해당 유틸리티로 이동하여 수행한다. 

사용자 수준 스레드는 커널 도움 없이 사용자 주소 공간에 구현된 스레드 패키지로 스레드 연산을 실행한다. 커널은 이런 과정을 모르고 프로세스를 계속 하나의 단위로 스케줄하고 하나의 실행 상태(준비, 실행, 대기 등)를 할당한다. 따라서 사용자 수준 스레드는 커널과 상관없이 다양한 목적의 응용 프로그램이나 언어 인터페이스의 요구에 적용할 수 있는 융통성이 장점이다. 응용 프로그램은 기본적으로 스레드 하나에서 시작하며 해당 스레드에서 실행을 시작한다.

사용자 수준 스레드를 이용하면 시스템은 다음과 같은 장점을 얻을 수 있다.

- 높은 이식성 : 기본 커널을 변경할 필요가 없으므로 모든 운영체제에 적용할 수 있어 이식성이 높다. 

- 오버헤드 감소 : 스레드 관리를 위한 모든 데이터 구조가 프로세스의 사용자 주소 공간에 있어 커널의 도움 없이 스레드 교환이 가능하다. 따라서 사용자와 커널 전환에 따른 오버헤드가 줄어든다. 

- 스케줄링의 유연성 : 스레드 라이브러리에서 스레드 스케줄링을 제어하기 때문에 스케줄링이 응용 프로그램에 맞게 적절하게 구성된다. 예를 들어, 라운드 로빈(Round Robin)이나 우선순위 기법을 이용할 수 있다.

반면, 사용자 수준 스레드를 이용하면 다음과 같은 제약을 받는다.

- 시스템의 동시성 지원 불가 : 한 번에 하나의 스레드만 커널에 접근할 수 있기 때문에 여러 스레드가 시스템 호출을 실행하면 해당 스레드뿐만 아니라 같은 프로세스에 있는 모든 스레드가 대기 상태가 된다.

- 시스템 규모 확장 제약 : 커널이 프로세스 내부의 다중 스레드를 프로세스로 하나로 관리한다. 따라서 다중 처리 환경이라도 여러 프로세서에서 분산 처리할 수 없으므로 시스템 규모를 확장하기 어렵다.

- 스레드 간 보호가 어려움 : 스레드 간의 보호에 커널의 보호 기법을 사용할 수 없다. 스레드 라이브러리에서 스레드 간 보호를 제공해야 프로세스 수준에서 보호된다. 

---
### 커널 수준 스레드
---
커널 수준 스레드는 사용자 수준 스레드의 한계를 해결하기 위해 사용자 스레드마다 커널 스레드, 즉 프로세서(실행 문맥)을 매핑하는 일대일 스레드 매핑을 지원한다. 사용자 스레드가 생성되면 그에 따른 커널 스레드가 생성된다. 다대일 방식에서 제기된 스레드 하나가 시스템을 호출하면 다른 스레드가 중단되는 문제를 해결할 수 있어 다중 프로세서에서 다중 스레드를 병렬로 실행할 수 있다.

하지만 자원이 제한적이라 사용자 수준 스레드 생성에 따라 커널 스레드를 무한정 생성할 수 없다. 또한 커널 스레드 생성으로 인한 오버헤드 증가로 응용 프로그램의 성능을 저하시킬 수 있으므로 시스템이 지원 스레드의 수를 제한해야 한다는 문제점이 있다.

커널 수준 스레드는 커널에 의해 생성, 삭제되고 커널의 텍스트와 전역 데이터를 공유하며, 자신만의 커널 스택을 가진다. 응용 프로그램, 즉 사용자 영역에는 스레드 관리를 위한 코드가 없다. 모든 응용 프로그램은 다중 스레드로 지원되고 응용 프로그램에 있는 스레드도 모두 하나의 프로세스에서 지원된다. 스레드 관리와 관련된 모든 작업을 커널(운영체제)이 지원하며 프로세스와 스레드에 대한 실행 문맥 정보를 유지한다. 

커널 수준 스레드는 커널에 의한 직접적인 스케줄링과 실행으로 사용자 수준 스레드가 겪는 커널 지원 부족 문제를 해결할 수 있다. 하지만 커널이 전체 프로세스와 프로세스 내 스레드를 위한 실행 문맥 정보를 유지하기 위해 오버헤드가 커지는 문제가 있다. 그런데 커널은 각 스레드를 개별적으로 관리할 수 있으므로 동시에 같은 프로세스의 다른 스레드를 스케줄링 할 수 있다. 커널 루틴 자체를 다중 스레드로 구성할 수 있기 때문에 커널은 프로세스에 있는 스레드 중 어느 하나가 대기 상태가 되더라도 다른 준비 상태 스레드를 실행할 수 있어 시스템 성능을 높일 수 있다. 물론, 앞서 지적한 것처럼 같은 프로세스에서 다른 스레드로 전환하는 과정에서 커널 모드 전환 오버헤드가  발생한다. 이러한 사실로 미루어 볼 때 커널 수준 스레드는 단일 스레드 프로세스보다 속도 향상이 가능하다. 커널 수준 스레드를 사용하면 병렬 실행의 이점을 이용해 시스템 규모 확장이 쉽고 처리량을 늘릴 수 있다는 장점을 얻을 수 있다. 

---
### 혼합형 스레드 지원
---
사용자 수준 스레드와 커널 수준 스레드를 혼합한 형태의 대표 예가 솔라리스다. 스레드 생성은 사용자 영역에서 이루어지며, 여러 개의 사용자 수준 스레드에 여러 개의 커널 스레드가 매핑되는 다대다 스레드 모델이다.

혼합형 스레드는 사용자 수준 스레드를 생성할 때마다 커널 수준 스레드를 생성하여 성능이 감소된다. 스레드 수가 제한되는 일대일 방식(커널 수준)과 다대일 방식(사용자 수준)에서 제기된 스레드는 시스템 호출 시 다른 스레드가 중단되는 문제를 해결하기 위한 방법이다. 

- 작업: 일반적인 프로세스다. 

- 사용자 수준 스레드: 프로세스의 주소 공간에 있는 스레드 라이브러리를 통해 실행되며, 응용 프로그램의 병렬 처리를 위한 인터페이스다.

- 경량 프로세스 스레드: 하나 이상의 사용자 수준 스레드를 지원하고 커널 스레드 하나에 매핑되며 커널에 의해 독립적으로 스케줄링된다. 다중 프로세서에서는 병렬로 실행된다.

- 커널 스레드: 프로세서에서 실행하기 위해 디스패치되고 스케줄링된다. 




















































































































































