---
프로세스 관리
---
프로세스는 실행 중에 프로세스 생성 시스템을 호출하여 새로운 프로세스를 생성할 수 있다. 이때 프로세스 생성 순서가 저장되고, 부모/자식 관계를 유지하며 계층적으로 생성된다. 여기서 생성하는 프로세스를 부모 프로세스, 생성되는 프로세스를 자식 프로세스 또는 서브 프로세스라 한다. 부모 프로세스가 여러 개의 자식 프로세스를 생성하면 계층 구조를 형성한다.

유닉스 시스템은 처음 부팅할 때, 식별자(PID, Process ID)가 0인 첫 번째 프로세스 Swapper를 생성하고 이어서 Init(PID=1)와 Pagedeamon(PID=2)을 생성한다. 이때 Swapper(PID=0)와 Pagedeamon(PID=2)을 운영체제 프로세스라고 하며 운영체제 모드에서만 실행된다. 모든 사용자 프로세스는 fork()명령을 통해 계층적으로 Init의 자식 프로세스로 생성된다. 

운영체제에서는 계층 프로세스를 관리하기 위해 다음과 같은 작업을 한다.

- 프로세스 생성

- 프로세스 종료

- 프로세스 제거

- 프로세스 중단(서스펜드)과 재시작

- 프로세스 우선순위 변경

- 문맥교환

---
### 프로세스 생성
---
운영체제가 프로그램을 선택하여 수행하기 시작하려면, 즉 새로운 프로세스를 생성하고  추가하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후 프로세스에 주소 공간을 할당 해야 한다. 일괄 처리 과정에서는 실행을 위해 작업이 준비 큐에 도착할 때, 대화형 환경에서는 새로운 사용자가 로그온(Log-on)할 때 프로세스가 생성된다.

프로세스는 운영체제에 의해, 또는 사용자의 응용 프로그램 요청에 의해 생성된다. 예를 들어, 사용자 요청에 의해 프린터를 구성시키는 프로세스를 생성하여 출력 작업을 할 수 있다.

생성되는 프로세스는 프로세스 식별자,우선순위,할당된 자원,자원 목록 같은 정보가 프로세스 제어 블록에 기록되고, 준비 상태가 되어 준비 목록의 맨 뒤에 위치된다. 따라서 프로세스를 생성하려면 다음과 같은 작업이 필요하다.

- 프로세스 식별자를 결정한다.

- 시스템에 알려진 프로세스 리스트에 식별자를 삽입한다.

- 프로세스에 초기 우선순위를 부여한다.

- 프로세스에 초기 우선순위를 부여한다.

- 프로세스 제어 블록을 생성한다.

- 프로세스에 초기 자원을 할당한다.

프로세스를 생성하는 과정을 단계별로 정리하면 다음과 같다.

- 1단계 : 새로운 프로세스에 프로세스 식별자를 할당한다.

- 2단계 : 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당한다.

- 3단계 : 프로세스 제어 블록을 초기화한다. 프로세스의 상태 정보/프로그램 카운터/스택 포인터 등의 초기화, 자원 요청, 프로세스 제어 정보(우선 순위) 등이 포함된다. 

- 4단계 : 링크한다(해당 큐에 삽입한다.)

일반적으로 프로세스가 작업을 수행하려면 프로세서 점유시간,메모리,파일,입출력장치 같은 자원이 필요하다. 프로세스가 자식 프로세스를 생성할 때는 필요한 자원을 운영체제로부터 직접 얻거나 부모 프로세스의 자원 일부를 사용할 수 있다. 부모 프로세스는 자식 프로세스에 자원을 나누어 주거나 일부 자원을 공유할 수 있는데, 자원의 일부만 사용하도록 제한하면 어떤 프로세스가 자식 프로세스를 너무 많이 생성하여 시스템에 부담을 주는 것을 방지할 수 있다.

프로세스가 생성될 때 획득하는 다양한 물리적, 논리적 자원 외에도 약간의 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달되는 경우가 있다. 예를 들어 <F1>이라는 파일의 상태를 단말기에 표시하는 <F1>프로세스가 있다고 해보자. 프로세스가 생성되면 부모 프로세스로부터 파일 이름을 입력받아 필요한 정보를 얻는다. 이때 출력장치의 기능도 받을 수 있다. 

프로세스가 새로운 프로세스를 생성할 때는 실행과 관련해 다음 두 경우가 가능하다.

- 부모 프로세스와 자식 프로세스가 동시에 실행된다.

- 부모 프로세스는 자식 프로세스들이 모두 종료될 때까지 기다린다.

새로운 프로세스의 주소 공간은 다음 두 경우가 가능하다.

- 자식 프로세스가 부모 프로세스의 주소 공간을 복사한다.

- 자식 프로세스가 별도의 프로그램을 적재한다.

이와 같은 수행 과정을 유닉스에서 살펴보자. 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가진다. 새로운 프로세스는 fork()명령(시스템 호출)에 의해 생성되고, 주소 공간은 부모 프로세스의 주소 공간을 복사한다. 따라서 부모 프로세스와 자식 프로세스의 정보 교환이 쉽다. 부모 프로세스와 자식 프로세스가 fork()명령을 동시에 수행하여 실행을 계속하면 복귀코드에서 자식 프로세스는 0, 부모 프로세스는 자식 프로세스의 식별자가 된다.(0이 아님). 다시 말해 fork()명령을 수행하면 자식 프로세스에는 0을 반환하지만 부모 프로세스에는 자식 프로세스의 식별자가 반환된다.


---
### 프로세스 종료
---
프로세스가 마지막 명령의 실행을 마치면 종료되고 운영체제에 프로세스 삭제를 요청한다. 일괄 처리 과정에서는 작업 종료를 의미하는 신호로 인터럽트를 발생시키거나 시스템 호출로 중지 명령을 전달해 프로세스를 완료한다. 대화형 환경에서는 사용자가 로그오프(Log-off)하거나 터미널을 닫을 때 프로세스가 종료한다.

이 외에도 abort 시스템 호출을 이용해 프로세스를 종료하기도 한다. abort는 종료되는 프로세스를 생성한 부모 프로세스만 호출할 수 있다. 이것은 부모 프로세스가 자식 프로세스를 생성하였으므로, 즉 생존권을 가져 다른 프로세스가 임의로 작업을 중단시킬 수 없기 때문이다. 자식 프로세스가 종료 될 때, 자식 프로세서의 신원(Identity)이 부모 프로세스에 전달된다.

부모 프로세스는 다음과 같은 이유로 자식 프로세스를 종료할 수 있다. 

- 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때

- 자식 프로세스에 할당된 작업(Task)이 더 이상 없을 때

일반적으로 시스템은 부모 프로세스가 종료되면 자식 프로세스의 존재를 허용하지 않아 종료시킨다. 이러한 현상을 연속 종료라 하고 운영체제가 수행한다.

유닉스에서는 exit 명령으로 프로세스를 종료하고, 부모 프로세스는 wait 명령을 사용하여 자식 프로세스의 종료를 기다린다. wait 명령은 종료된 자식의 프로세스 식별자를 부모 프로세스에 돌려주므로 어떤 자식 프로세스가 종료되었는지 알 수 있다.

다음은 프로세스를 종료하는 경우와 그 예다.

- 정상종료: 프로세스가 운영체제의 서비스를 호출한 경우

- 시간 초과: 프로세스가 명시된 전체 시간을 초과하여 실행되거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다리는 경우

- 실패: 파일 검색 실패, 명시된 횟수를 초과하여 입출력이 실패한 경우

- 산술 오류, 보호 오류, 데이터 오류 등

- 메모리 부족, 접근 위반 등

---
### 프로세스 제거
---
프로세스 제거는 프로세스를 파괴하는 것이다. 프로세스를 제거하면 프로세스에 속한 자원을 시스템으로 돌려주고 해당 프로세스는 시스템 리스트나 테이블에서 사라지며 프로세스 제어 블록이 회수된다. 하지만 프로그램은 디스크에 저장된다. 부모 프로세스가 제거되면 해당 자식 프로세스도 자동으로 제거된다. 

---
### 프로세스 중단과 재시작
--- 
앞서 살펴본 프로세스의 준비, 실행, 대기(보류) 상태만 이용하면 입출력 동작이 일반 연산보다 너무 느리기 때문에 시스템의 활동 시간이 대부분 유휴 상태가 된다. 다중 프로그래밍 환경에서도 프로세서의 동작 시간이 입출력보다는 짧아 프로세스 이동이 발생한 뒤에도 기다리게 되어 대부분의 시간을 유휴하게 된다. 예를 들어, 윈도우에서 다수의 응용 프로그램을 동작시킬 때, 현재 수행 중인 윈도우 외의 것은 대기 상태가 되어 비활성화된다.

이런 문제는 프로세스 중단(일시정지) 상태를 이용해 해결할 수 있다. 운영체제는 다음 두가지 방법으로 프로세스를 실행할 수 있다. 첫째, 새로운 프로세스를 생성하여 실행한다. 둘째, 이미 실행 중인 프로세스를 중단시켰다가 다시 실행한다.

이 중 프로세스를 일시 중단시켰다가 다시 실행하는 두 번째 방법을 이용하면 시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스를 제공할 수 있다. 실행에서 대기(보류)가 아닌 중단(일시중지) 상태를 추가하면, 특정 이벤트의 발생을 기다리며 대기 상태가 되기 때문에 해당 이벤트가 발생하면 즉시 실행 상태로 변화할 수 있다는 이점이 있다.

다중 프로그래밍에서 중단은 프로세스 입출력 요구 외의 다른 원인에 의해 프로세스가 실행을 중단한 상태, 즉 자원 부족(대기) 상태를 의미하기도 한다. 물론, 중단된 프로세스는 기다리는 이벤트(예를 들어, 입출력 완료 인터럽트가 발생)가 발생하면 중단 이전의 상태로 되돌아갈 수 있다. 이처럼 중단 원인이 제거되어 다시 실행되는 것을 재시작이라고 한다. 프로세스 중단과 재시작은 시스템 부하를 조정하는데 상당히 중요한데, 주로 다음과 같은 경우에 발생한다.

- 시스템 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가, 시스템이 기능을 회복할 때 다시 재시작할 수 있다.

- 프로세스의 어느 부분이 의심스러울 때 사용자는 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 정지할 수 있다.

- 처리할 일이 너무 많아 시스템 부담이 크면 프로세스 몇개를 중단했다가 시스템이 다시 정상으로 돌아왔을 때 재시작할 수 있다.

---
### 프로세스 우선순위 변경
---
프로세스 제어 블록의 우선순위 값을 변경할 수 있으며 프로세스 스케줄러는 준비 리스트의 우선순위를 이용해 프로세스를 처리한다. 프로세스 실행 상태에서 준비 상태가 되는 경우는 할당 시간을 초과할 경우다. 준비 리스트에 있는 프로세스는 프로세서 중심 프로세스(낮은 우선순위)와 입출력 중심의 프로세스(높은 우선순위)로 구분한다. 입출력 프로세스는 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스에 높은 우선순위를, 속도가 빠른 디스크 입출력 프로세스에는 낮은 우선순위를 부여한다. 우선순위가 낮은 프로세스에는 시간 할당량을 크게 제공하고 우선순위가 높은 프로세스에는 시간 할당량을 적게 제공한다. 따라서 입출력 중심의 프로세스는 프로세서를 자주 짧게 사용하고, 프로세서 중심 프로세스는 프로세서 사용 횟수는 적지만 한번에 오래 사용하게 하여 균형을 유지한다.

---
### 문맥교환
---
인터럽트는 현재 실행되는 프로세스와 별도로 외부에서 발생되는 여러 종류의 이벤트(예를 들면 입출력 동작의 종료)에 의해 발생한다. 이와 달리 트랩(Trap)이라는 것이 있는데, 이것은 부적절한 파일 접근이나 현재 실행 중인 프로세스에 의해 발생되는 오류나 예외 상황 때문에 발생한다.

일반적인 인터럽트는 제어가 인터럽트 처리 루틴으로 넘어간 후에도 기본 시스템 관리 작업을 처리하고 인터럽트 형태에 따라 관련된 운영체제 루틴으로 분기한다. 다음은 대표적인 인터럽트 예이다.

- 입출력 인터럽트: 입출력 동작이 발생한 사실을 확인한 후 이벤트를 기다리는 프로세스를 준비 상태로 바꾸고 실행할 프로세스를 결정한다.

- 클록 인터럽트: 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 바꾸고 다른 프로세스를 디스패치하여 실행 상태로 바꾼다.

실행 중인 프로세스가 인터럽트 되면 운영체제는 다른 프로세스를 실행 상태로 바꾸고 해당 프로세스에 제어를 넘겨준다. 이 과정에서 실행 중인 프로세스로부터 제어를 인수한 운영체제는 또 다른 프로세스에 제어를 넘겨주기 위해 프로세스 교환이 일어날 수 있다. 

대부분의 운영체제에서는 프로세스 교환으로 인터럽트가 발생하지 않는다. 인터럽트 처리 루틴을 실행한 후 현재 실행 중인 프로세스가 다시 재실행될 수 있기 때문이다. 이와 달리 트랩은 우선 시스템은 치명적인 오류인지 판단하여 치명적 오류면 프로세스를 종료하면서 프로세스 교환이 일어난다. 프로세스를 다른 프로세스로 교환하려면 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재해야 하는데, 이런 일련의 과정을 문맥교환(context switching)이라 한다. 예를 들어, 프로세스가 '준비-실행' 상태로 변하거나, '실행-준비', 또는 '실행-대기' 상태로 변할 때 문맥교환이 발생한다.

문맥교환은 오버헤드가 발생한다. 그리고 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 존재에 따라 다르므로 시스템마다 다르다. 

일반적으로 운영체제에서는 문맥교환이 자주 발생한다. 따라서 가능한 효율적으로 구현해야 하는데, 현대의 운영체제는 다음 절에서 설명할 스레드(Thread)를 이용하여 문맥교환을 효율적으로 처리한다.




















































