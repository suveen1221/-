---
프로세스 관리
---
프로세스는 실행 중에 프로세스 생성 시스템을 호출하여 새로운 프로세스를 생성할 수 있다. 이때 프로세스 생성 순서가 저장되고, 부모/자식 관계를 유지하며 계층적으로 생성된다. 여기서 생성하는 프로세스를 부모 프로세스, 생성되는 프로세스를 자식 프로세스 또는 서브 프로세스라 한다. 부모 프로세스가 여러 개의 자식 프로세스를 생성하면 계층 구조를 형성한다.

유닉스 시스템은 처음 부팅할 때, 식별자(PID, Process ID)가 0인 첫 번째 프로세스 Swapper를 생성하고 이어서 Init(PID=1)와 Pagedeamon(PID=2)을 생성한다. 이때 Swapper(PID=0)와 Pagedeamon(PID=2)을 운영체제 프로세스라고 하며 운영체제 모드에서만 실행된다. 모든 사용자 프로세스는 fork()명령을 통해 계층적으로 Init의 자식 프로세스로 생성된다. 

운영체제에서는 계층 프로세스를 관리하기 위해 다음과 같은 작업을 한다.

- 프로세스 생성

- 프로세스 종료

- 프로세스 제거

- 프로세스 중단(서스펜드)과 재시작

- 프로세스 우선순위 변경

- 문맥교환

---
### 프로세스 생성
---
운영체제가 프로그램을 선택하여 수행하기 시작하려면, 즉 새로운 프로세스를 생성하고  추가하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후 프로세스에 주소 공간을 할당 해야 한다. 일괄 처리 과정에서는 실행을 위해 작업이 준비 큐에 도착할 때, 대화형 환경에서는 새로운 사용자가 로그온(Log-on)할 때 프로세스가 생성된다.

프로세스는 운영체제에 의해, 또는 사용자의 응용 프로그램 요청에 의해 생성된다. 예를 들어, 사용자 요청에 의해 프린터를 구성시키는 프로세스를 생성하여 출력 작업을 할 수 있다.

생성되는 프로세스는 프로세스 식별자,우선순위,할당된 자원,자원 목록 같은 정보가 프로세스 제어 블록에 기록되고, 준비 상태가 되어 준비 목록의 맨 뒤에 위치된다. 따라서 프로세스를 생성하려면 다음과 같은 작업이 필요하다.

- 프로세스 식별자를 결정한다.

- 시스템에 알려진 프로세스 리스트에 식별자를 삽입한다.

- 프로세스에 초기 우선순위를 부여한다.

- 프로세스에 초기 우선순위를 부여한다.

- 프로세스 제어 블록을 생성한다.

- 프로세스에 초기 자원을 할당한다.

프로세스를 생성하는 과정을 단계별로 정리하면 다음과 같다.

- 1단계 : 새로운 프로세스에 프로세스 식별자를 할당한다.

- 2단계 : 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당한다.

- 3단계 : 프로세스 제어 블록을 초기화한다. 프로세스의 상태 정보/프로그램 카운터/스택 포인터 등의 초기화, 자원 요청, 프로세스 제어 정보(우선 순위) 등이 포함된다. 

- 4단계 : 링크한다(해당 큐에 삽입한다.)

일반적으로 프로세스가 작업을 수행하려면 프로세서 점유시간,메모리,파일,입출력장치 같은 자원이 필요하다. 프로세스가 자식 프로세스를 생성할 때는 필요한 자원을 운영체제로부터 직접 얻거나 부모 프로세스의 자원 일부를 사용할 수 있다. 부모 프로세스는 자식 프로세스에 자원을 나누어 주거나 일부 자원을 공유할 수 있는데, 자원의 일부만 사용하도록 제한하면 어떤 프로세스가 자식 프로세스를 너무 많이 생성하여 시스템에 부담을 주는 것을 방지할 수 있다.

프로세스가 생성될 때 획득하는 다양한 물리적, 논리적 자원 외에도 약간의 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달되는 경우가 있다. 예를 들어 <F1>이라는 파일의 상태를 단말기에 표시하는 <F1>프로세스가 있다고 해보자. 프로세스가 생성되면 부모 프로세스로부터 파일 이름을 입력받아 필요한 정보를 얻는다. 이때 출력장치의 기능도 받을 수 있다. 

프로세스가 새로운 프로세스를 생성할 때는 실행과 관련해 다음 두 경우가 가능하다.

- 부모 프로세스와 자식 프로세스가 동시에 실행된다.

- 부모 프로세스는 자식 프로세스들이 모두 종료될 때까지 기다린다.

새로운 프로세스의 주소 공간은 다음 두 경우가 가능하다.

- 자식 프로세스가 부모 프로세스의 주소 공간을 복사한다.

- 자식 프로세스가 별도의 프로그램을 적재한다.

이와 같은 수행 과정을 유닉스에서 살펴보자. 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가진다. 새로운 프로세스는 fork()명령(시스템 호출)에 의해 생성되고, 주소 공간은 부모 프로세스의 주소 공간을 복사한다. 따라서 부모 프로세스와 자식 프로세스의 정보 교환이 쉽다. 부모 프로세스와 자식 프로세스가 fork()명령을 동시에 수행하여 실행을 계속하면 복귀코드에서 자식 프로세스는 0, 부모 프로세스는 자식 프로세스의 식별자가 된다.(0이 아님). 다시 말해 fork()명령을 수행하면 자식 프로세스에는 0을 반환하지만 부모 프로세스에는 자식 프로세스의 식별자가 반환된다.


---
### 프로세스 종료
---
프로세스가 마지막 명령의 실행을 마치면 종료되고 운영체제에 프로세스 삭제를 요청한다. 일괄 처리 과정에서는 작업 종료를 의미하는 신호로 인터럽트를 발생시키거나 시스템 호출로 중지 명령을 전달해 프로세스를 완료한다. 대화형 환경에서는 사용자가 로그오프(Log-off)하거나 터미널을 닫을 때 프로세스가 종료한다.

이 외에도 abort 시스템 호출을 이용해 프로세스를 종료하기도 한다. abort는 종료되는 프로세스를 생성한 부모 프로세스만 호출할 수 있다. 이것은 부모 프로세스가 자식 프로세스를 생성하였으므로, 즉 생존권을 가져 다른 프로세스가 임의로 작업을 중단시킬 수 없기 때문이다. 자식 프로세스가 종료 될 때, 자식 프로세서의 신원(Identity)이 부모 프로세스에 전달된다.

부모 프로세스는 다음과 같은 이유로 자식 프로세스를 종료할 수 있다. 

- 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때

- 자식 프로세스에 할당된 작업(Task)이 더 이상 없을 때

일반적으로 시스템은 부모 프로세스가 종료되면 자식 프로세스의 존재를 허용하지 않아 종료시킨다. 이러한 현상을 연속 종료라 하고 운영체제가 수행한다.

유닉스에서는 exit 명령으로 프로세스를 종료하고, 부모 프로세스는 wait 명령을 사용하여 자식 프로세스의 종료를 기다린다. wait 명령은 종료된 자식의 프로세스 식별자를 부모 프로세스에 돌려주므로 어떤 자식 프로세스가 종료되었는지 알 수 있다.

다음은 프로세스를 종료하는 경우와 그 예다.

- 정상종료: 프로세스가 운영체제의 서비스를 호출한 경우

- 시간 초과: 프로세스가 명시된 전체 시간을 초과하여 실행되거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다리는 경우

- 실패: 파일 검색 실패, 명시된 횟수를 초과하여 입출력이 실패한 경우

- 산술 오류, 보호 오류, 데이터 오류 등

- 메모리 부족, 접근 위반 등

---
### 프로세스 제거
---
프로세스 제거는 프로세스를 파괴하는 것이다. 프로세스를 제거하면 프로세스에 속한 자원을 시스템으로 돌려주고 해당 프로세스는 시스템 리스트나 테이블에서 사라지며 프로세스 제어 블록이 회수된다. 하지만 프로그램은 디스크에 저장된다. 부모 프로세스가 제거되면 해당 자식 프로세스도 자동으로 제거된다. 

---
### 프로세스 중단과 재시작
--- 



























