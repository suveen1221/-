---
### 메모리
메모리는 컴퓨터 성능과 밀접하므로 사용자는 당연히 크고 빠르며 비용이 저렴한 메모리를 요구한다. 하지만 속도가 빠른 메모리는 가격이 비싸다.

---
메모리 계층 구조는 다양한 레벨의 메모리를 연결하여 비용,속도,용량,접근 시간 등을 상호보완한 것이다. 메모리는 속도는 느리나 용량이 큰 보조장치(자기 테이프 등)부터 속도는 빠르나 용량이 작은 레지스터까지 종류가 다양하다. 메인 메모리를 중심으로 아래는 대용량의 자기 디스크,이동이 편리한 광학 디스크,파일을 저장하기 위한 속도가 느린 자기 테이프가 있다. 위로는 메인 메모리와 프로세서의 속도 차를 보완하기 위한 캐시가 있으며, 메모리 계층의 최상위에는 프로세서가 사용할 자료를 보관하는 가장 빠른 기억 소자인 레지스터가 있다. 이러한 메모리 계층구조는 비용,속도,크기(용량)가 다른 메모리를 효과적으로 이용해 시스템의 성능을 향상시키는 데 사용할 수 있다.

메모리 계층 구조는 1950년대와 1960년대 메인 메모리가 너무 비싸다는 문제 때문에 제안된 방법이다. 프로그램과 데이터를 실행하고 참조하려면 모두 메인 메모리에 있어야 한다. 그런데 메모리 계층 구조에서는 즉시 필요하지 않은 프로그램과 데이터를 필요할 때까지 보조기억장치에 저장했다가 실행,참조하려고 할 때 메인 메모리로 옮긴다.

메모리 계층 구조를 이용할 수 있는 이유는 메모리 참조가 임의로 이루어지는 것이 아니라 지역성(국부성)이라는 특징이 있기 때문이다.

지역성은 실행 중인 프로세서가 실행기간 동안 메모리 정보를 균일하게 접근하지 않고 블록중 일부만 집중적으로 참조하는 현상이다. 지역성은 다음과 같은 이유로 발생한다.

- 프로그램은 명령어를 순차적으로 실행하는 경향이 있으므로 명령어는 특정 지역 메모리에 인접해 있다.

- 프로그램은 순환(단일 순환,중첩된 순환 등)의 반복이지만 메모리 참조 영역은 일부 영역에 국한된다.

- 대부분의 컴파일러는 메모리에 인접한 블록, 즉 배열로 저장하므로 프로그램은 배열 원소를 순차적으로 자주 접근하게 되어 지역적인 배열 접근 경향을 보인다.

---
##### 메인 메모리
메인 메모리는 고유 주소를 가진 워드나 바이트로 구성된 대규모 배열이다. 주소를 읽거나 기록함으로써 상호 작용한다는 특성이 있다. 예를 들어, 프로세서는 메인 메모리로부터 처리할 데이터를 가져오거나 처리한 결과를 메인 메모리에 저장한다. 입출력장치 역시 메인 메모리에서 데이터를 받거나 저장한다.

<프로세서> - <메인 메모리> - <입출력장치>

메인 메모리는 다수의 셀(cells)로 구성되며 각 셀은 비트들로 구성된다. 만약 셀이 k비트면 2*k(2의 k제곱)값을 저장할 수 있다. 메인 메모리에 데이터가 저장될 때는 셀 하나에 저장되거나 여러 셀에 나누어 저장한다. 셀은 주소에 의해 참조되는데 n비트라면 참조 주소 범위는 0~2*n-1(2의 n제곱 -1)이다.

이와 같이 컴퓨터에 주어진 주소 공간을 물리적 주소 공간이라고 하는데 프로그래머는 물리적 주소를 직접 사용하지 않고 수식이나 변수를 사용한다. 그리고 컴파일러가 프로그램을 기계 명령어로 변환할 때 변수와 명령어에 주소를 할당하는데, 이 주소를 논리적 주소(또는 가상 주소)라 한다. 논리적 주소는 별도의 주소 공간에 나타난다. 컴파일은 원시 프로그램을 기계 명령어로 변환하는 처리 과정인데, 이 과정에서 컴파일러가 논리적 주소를 물리적 주소로 변환한다. 물론, 주소 지정 관련 기술의 형태는 컴퓨터 하드웨어에 따라 다르게 정의된다. 

메모리 속도는 어떤 동작의 시작과 종료 사이의 경과 시간으로 메모리 접근 시간과 메모리 사이클 시간으로 표현할 수 있다. 먼저 메모리 접근 시간은 명령 발생 후 목표 번지를 검색하여 데이터 쓰기(읽기)를 시작할 때까지의 시간이다. 예를 들어, 읽기 제어 신호를 가한 후 데이터가 메모리 버퍼 레지스터까지 나오는 데 걸리는 시간이다. 그리고 메모리 사이클 시간은 두 번의 연속적인 메모리 동작 사이에 필요한 최소 지연 시간으로, 같은 예에서 읽기 제어 신호를 가한 후 다음 읽기 제어 신호를 가할 수 있을 때까지의 시간이다. 일반적으로 사이클 시간이 접근 시간보다 약간 크며 메모리의 세부 구현 방법에 따라 달라진다.

앞서 언급했듯이, 메인 메모리는 프로세서가 사용할 프로그램이나 데이터를 저장하는 작업장이다. 프로세서-메모리-디스크 사이에서 발생하는 디스크 입출력 병목 현상을 해결하는 역할을 한다. 그런데 프로세서와 메모리 사이의 접근 속도 차가 커짐에 따라 메인 메모리의 부담을 줄이기 위해 프로세서 칩 안이나 외부에 별도의 캐시를 구현하기도 한다. 

가상 메모리(Virtual Memory)는 메인 메모리의 유효 크기를 늘리는 기법으로 디스크 같은 보조기억장치에 프로그램이나 데이터를 저장했다가 필요할 때 다시 메인 메모리로 이동시키는 기술이다. 현재 실행 중인 프로그램이나 데이터는 물리적인 메인 메모리 영역에 전부 저장해야 하지만 메인 메모리의 공간 부족으로 다 저장할 수 없다. 이럴 때 가상 메모리를 이용하여 프로그램과 데이터를 보조기억장치에 일부 저장했다가 필요할 때 다시 메인 메모리로 옮겨 실행하면 효과적이다.

가상 메모리의 특징을 성공적으로 활용하려면 실행 중인 프로세스가 참조하는 주소와 메인 메모리에서 사용하는 주소를 분리해야 한다. 앞서 언급했듯이, 일반적으로 현재 진행 중인 프로세스가 참조하는 주소를 논리적 주소(가상 주소,프로그램 주소)라 하고 메모리의 실제 주소를 물리적 주소라 한다. 그리고 논리적 주소를 물리적 주소로 변환하는 과정을 매핑(사상,Mapping)또는 메모리 맵(Memory Map)이라 한다.

가상 메모리는 메인 메모리보다 훨씬 큰 저장 용량의 주소를 지정할 수 있어 프로그램을 부분 적재하여 실행할 수 있다. 즉, 실제 수행 중인 부분만 실제 메인 메모리로 매핑하고 나머지는 보조기억장치로 매핑한다.

---
##### 캐시
캐시는 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리 사이에서 데이터나 정보를 저장하는 고속 버퍼다. 메모리에 캐시를 결합한 캐시 메모리 시스템은 메모리 가격과 성능을 절충하여 느린 메모리 때문에 발생하는 성능 저하를 줄여준다. 캐시는 메인 메모리에서 일정 블록의 데이터를 가져와 워드 단위로 프로세서에 전달하여 정보를 빠르게 제공한다. 또한 데이터가 이동할 수 있는 통로를 확대하여 프로세서와 메인 메모리의 속도 차이를 줄여주는 역할을 한다.

보통 캐시는 크기가 8~64바이트 정도인 블록 여러 개로 구성되며, 각 블록의 크기는 메인 메모리의 블록 크기와 같다. 

캐시의 동작을 좀 더 구체적으로 살펴보면 일반적으로 메인 메모리의 주소는 태그(tag)영역과 주소 영역을 나타내는 연속된 값으로 구성된다. 그리고 캐시는 메인 메모리 주소 영역을 한 번 읽어 들일 수 있는 라인 크기로 나눈 후 각 블록에 번호를 부여한 후 이 번호를 태그로 저장한다.

프로세서는 메인 메모리 접근이 필요하면 먼저 캐시를 조사한다. 캐시 태그와 메모리 주소의 태그 영역을 비교하여 원하는 블록을 찾는다. 만약, 읽기 연산이고 캐시가 데이터를 보관하고 있으면(캐시 태그와 메모리 주소 태그각 일치하면) 캐시는 데이터 라인에서 요청한 데이터를 읽어 프로세서에 보낸다. 이것을 캐시 적중이라 하며 프로세서가 메인 메모리에서 데이터를 직접 읽어오는 것보다 훨씬 빠르다. 그러나 원하는 주소의 블록이 캐시에 없으면 캐시 실패가 발생하고 캐시 제어기는 메인 메모리에서 해당 블록을 읽어 캐시에 넣고 프로세서에 전송한다. 이때 캐시에는 대응된 주소 태그와 내용이 함께 전송된다.

---
#### 주변장치
주변장치는 입력장치나 출력장치처럼 컴퓨터 기능을 향상시키기 위한 추가 장비다. 보조기억장치(플로피 디스크,하드 디스크,CD/DVD,테이프 드라이브),스캐너,모뎀 등도 주변 장치에 속한다.

---
 
























