---
### 운영체제 기능의 발전
---
운영체제와 컴퓨터 구조,즉 하드웨어는 서로 밀접하게 영향을 준다. 하드웨어 사용률 증가를 위해 운영체제가 개발되고, 운영체제가 제공할 핵심 사항을 지원하기 위해 하드웨어가 개발되었기 때문이다. 따라서 현재 사용 중인 운영체제의 기능을 이해하기 위해서는 그동안 컴퓨터 시스템이 운영체제와 함께 어떻게 발전해왔는지 살펴보아야 한다.

초기의 컴퓨터 시스템은 작업별 처리 시스템이었다. 속도가 느리고 온라인 판독기와 프린터에만 의존하여 작업을 수행하였는데 시간이 많이 소요되었다. 특히 컴퓨터에 하드웨어만 있어서 프로그래머가 콘솔용으로 작성한 프로그램을 종이 테이프나 펀치 카드에서 메모리로 적재한 후, 시작 주소를 설정하고 실행해야 했다. 그리고 프로그램 실행 과정을 콘솔을 통해 살펴볼 수 있었다.

콘솔은 컴퓨터 전면에 있는 스위치나 감시등을 통해 메모리에 프로그램을 넣거나 메모리 내용을 볼 수 있는 장치다. 오류를 발견하면 프로그래머는 프로그램을 중지하고 메모리와 시스템의 내용을 조사한 후 콘솔에서 프로그램을 수정,변경할 수 있다.

당시의 프로그램은 대부분 2진수나 8진수 기계어로 작성되었고 절대 주소를 사용했으며 라이브러리 루틴도 없었다. 로더는 한 번에 카드를 한 장씩만 적재할 수 있을 정도로 용량이 작았으며, 메모리 내용은 대부분 사용자 자신이 직접 작성한 프로그램이었다. 물론, 실행 명령을 사용자가 직접 작성하여 사용자가 프로그램이 무슨 일을 하는지 정확히 알 수 있었다. 또한 수동 대화 방식으로 진행하여 프로그래머가 시스템 오퍼레이터가 되고 시스템 사용을 위해 신청을 예약하는 예약 제도로 운영됐다. 그런데 이 방법은 문제가 있었다. 예를 들어, 사용자가 개발 프로그램을 수정하기 위해 컴퓨터를 한 시간 예약했는데, 결함이 생겨 한 시간 안에 못 마쳐도 하던 일을 멈추고 다른 사용자에게 컴퓨터를 넘겨주고 기다려야 했다. 반대로 예약한 시간보다 빠르게 35분만에 마쳐도 25분은 유휴 시간이 되었다.

시간이 지남에 따라 카드 판독기,라인 프린터,자기 테이프가 보편화되었다. 그리고 프로그래밍을 쉽게 하기 위해 어셈블러,로더,링커 등이 개발되었다. 그리고 공통 기능을 위한 라이브러리가 만들어져 공통 기능을 새로 작성할 필요 없이 작성할 프로그램에 삽입할 수 있게 되었다. 아울러 포트란,코볼 등의 컴파일러가 개발되어 프로그래밍 업무가 좀 더 쉬워졌지만 컴퓨터 동작은 훨씬 복잡해졌다. 예를 들어, 프로그래머가 포트란 프로그램을 실행하려면 먼저 포트란 컴파일러를 컴퓨터에 적재해야 한다. 그리고 컴파일러는 보통 자기 테이프에 적재되기 때문에, 테이프를 테이프 드라이버에 설치하고 프로그램을 카드 판독기로 읽어 또 다른 테이프에 저장해야 한다. 이때 포트란 컴퓨터는 어셈블러 언어를 생성한 후 출력하는 어셈블리 과정이 필요해 어셈블러가 수록된 또 다른 테이프가 필요하다. 이 과정은 다음과 같이 8단계로 정리할 수 있다. 

- 포트란 컴파일러 테이프를 적재한다.
- 컴파일러를 실행한다.
- 컴파일러를 제거한다.
- 어셈블러 테이프를 적재한다.
- 어셈블러를 실행한다.
- 어셈블러 테이프를 제거한다.
- 목적 프로그램을 적재한다.
- 목적 프로그램을 실행한다.

 이 방법은 작업 하나를 수행하는 데 필요한 준비 시간 단계가 많아 시간이 낭비된다. 그리고 한 단계에서 오류가 발생하면 처음부터 다시 수행해야 하는 불편함까지 있었다.
 
---
#### 모니터
앞서 살펴본 방법은 작업 준비 시간이 문제가 된다. 테이프를 적재하거나 프로그래머가 콘솔을 동작시키는 동안 프로세서(중앙처리장치,CPU)가 아무 일도 할 수 없기 때문이다. 이럴 때 컴퓨터 처리율을 높이기 위해 다음 방법을 고려할 수 있다.

첫째, 컴퓨터 운용을 촉진하기 위해 전문 오퍼레이터를 채용한다. 프로그래머는 기계 동작에 간섭할 필요가 없고, 전문 오퍼레이터는 작업 하나를 완료하자마자 다음 작업을 수행할 수 있었다. 특히 오퍼레이터는 풍부한 경험으로 준비 시간을 줄이고 컴퓨터 예약제로 인한 유휴시간을 줄일 수 있었다. 하지만 프로그램을 이해할 수 없어 오류 수정이 어렵고, 메모리와 레지스터의 내용을 출력하여 오류를 수정해야 해 프로그래머에게 많은 어려움을 줄 수 있다.

둘째, 유사 작업을 묶어 일괄 처리하는 방법을 작업 스케쥴링 기법에 도입하여 준비 시간을 줄인다. 예를 들어, 오퍼레이터가 포트란,코볼,포트란 작업을 수행한다면 이를 포트란,포트란,코볼 순으로 처리하면 위해 준비 작업을 한 번만 하기 때문에 준비 시간을 줄일 수 있다.

---
#### 오프라인 연산
---
일괄 처리 시스템을 자동 작업 순서로 전환함으로써 성능은 높였지만 종종 유휴 시간이 발생하는 문제점이 있다. 이는 기계적인 입출력장치의 처리 속도가 전자적 속도의 프로세서보다 매우 느렸기 때문이다.  프로세서는 초당 수백만 개의 명령을 수행하는 마이크로 초 단위인데 반해 카드 판독기는 분당 1,000여 장의 카드(초당17장)를 읽을 수 있었다. 따라서 프로세서와 입출력장치의 속도는 최소 세 자리 수만큼 차이가 났다.

---
#### 버퍼링
---
버퍼링도 운영체제의 기능 중 하나다. 일반적으로 상주 모니터 혹은 장치 드라이버는 각 입출력장치를 위해 시스템 입출력 버퍼를  가지는데, 이는 입출력장치의 느린 속도를 보완하기 위해 이용된다. 버퍼링은 프로세서와 입출력장치를 항상 분주하게, 즉 유휴 시간이 없도록 프로세서의 연산 과정과 함께 어떤 작업의 입출력을 동시에 수행하는 아주 간단한 방법이다. 레코드 하나를 판독하여 프로세서가 연산을 시작하기 직전 입력장치가 다음 입력을 즉시 받아들이도록 명령했다고 치자. 그러면 프로세서와 입력장치가 동시에 가동된다.

프로세서가 다음 데이터 레코드를 준비하고 있을 때 입력장치가 입력을 종료하면, 프로세서는 방금 판독한 레코드를 바로 처리할 수 있고 입력장치는 다음 레코드를 읽어 들일 수 있어 시스템 성능이 향상되는 효과를 준다. 출력에서도 이와 유사한 버퍼링을 수행할 수 있다. 출력장치가 데이터를 받아들일 동안 프로세서가 데이터를 생성하여 버퍼에 넣는다.

버퍼링을 위한 데이터 구성 단위로 레코드가 쓰인다. 레코드는 키보드로부터 입력받은 하나의 블록 같은 실제 레코드일 수도 있고, 입력 한 라인,영어 단어 하나,배열 하나처럼 논리적 레코드일 수 있다. 논리적 레코드는 응용 프로그램에 의해 정의되고 물리적 레코드는 입출력장치의 특성에 의해 정의된다. 따라서 버퍼링의 성능은 처리되는 레코드 수에 따라 달라진다. 예를 들어, 프로세서와 입출력장치의 평균 속도(초당 읽어 들이는 레코드 수)가 동일하면 버퍼링은 두 장치가 속도를 충분히 낼 수 있게 해준다. 하지만 프로세서가 입력장치보다 평균 속도가 아주 빠르면 프로세서는 항상 빈 버퍼에 입력을 기다려야 하기 때문에 버퍼링을 사용할 필요가 없다.

출력과 관련해 프로세서는 출력 자료가 시스템 버퍼에 채워질 때까지 계속 처리할 수 있다. 이때 프로세서는 출력장치를 위해 기다려야 한다. 이런 상황은 프로세서 스스로 계산하는 것 보다 상대적으로 입출력 양이 많은 입출력 중심 작업에서 발생한다. 그러므로 프로세서는 입출력장치 속도의 제한을 받게 된다.

반면, 계산 양이 많은 프로세서 중심 작업에서는 입력 버퍼가 항상 채워져 있고 출력 버퍼는 항상 빌 수 있다. 따라서 버퍼링 기능은 충분하지 않지만 어느 정도 도움이 될 수 있다. 초기 시스템의 작업은 대부분 입출력 주임이었고 입출력장치(카드 판독기,라인 프린터)는 프로세서에 비해 너무 느렸다.

---
#### 스풀링
---
테이프 시스텡의 문제점은 프로세서가 다른 부분을 판독하고 있는 동안 추가로 기록할 수 없다는 것이다. 반면, 디스크 시스템에서는 헤드가 디스크의 한 영역에서 다른 영역으로 빠르게 이동하기 때문에 추가 기록이 가능하다. 예를 들어, 디스크는 카드 판독기가 사용하는 영역에서 다음 카드를 읽기 위해 프로세서에 필요한 다른 영역으로 빠르게 이동할 수 있다.

이러한 디스크의 특성을 이용하여 스풀링기법이 개발되었다. 스풀링은 'Simultaneous Peripheral On-Line' 이라는 의미로 디스크를 매우 큰 버퍼처럼 사용하는 것이다. 즉, 입력장치에서 미리 읽어들여 출력장치가 받을 수 있을 때까지 출력파일을 저장한다. 스풀링은 카드 판독 작업,출력 작업,카드 펀치 작업 등을 오프라인으로 수행하는 과정으로 앞서 설명한 버퍼링이 컴퓨터의 하드웨어의 일부, 즉 버퍼를 사용한다면 스풀링은 별개의 오프라인 장치를 사용한다는 차이가 있다.

버퍼링에 비해 스풀링은 한 작업의 입출력을 수행하면서 다른 작업의 계산도 할 수 있다는 장점이 있다. 간단한 시스템에서도 스풀러는 한 작업의 결과물을 출력하는 동안 다른 작업의 입력을 읽어 들일 수 있으며 또 다른 작업도 수행할 수 있다. 버퍼링이 한 작업의 입출력과 그 작업의 계산만 함께 할 수 있는데 반해, 스풀링은 많은 작업의 입출력과 계산을 함께 할 수 있다.

스풀링은 성능에 직접적으로 이득이 된다. 일정 정도의 디스크 공간과 테이블을 약간 가진 프로세서는 한 작업의 계산과 다른 작업의 입출력을 중복해서 처리할 수 있다. 따라서 스풀링은 프로세서와 입출력장치가 아주 높은 효율로 작업할 수 있도록 해준다. 특히 프로세서 중심 작업과 입출력 중심 작업이 혼합된 작업에 더 좋다.

스풀링은 작업 풀이라는 중요한 데이터 구조를 제공하는데, 이것은 디스크에 읽혀져 실행을 위해 대기하는 여러 작업을 수행할 수 있도록 준비해 준다. 그리고 디스크에 저장된 작업은 프로세서 이용률을 향상시키기 위해서 운영체제가 다음에 수행할 작업을 선택할 수 있도록 해준다.

---




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
